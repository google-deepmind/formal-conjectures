import Batteries.Data.List.Lemmas
import Init.Data.List.OfFn
import Init.Data.Nat.Basic
import Mathlib.Algebra.BigOperators.Group.Finset.Basic
import Mathlib.Algebra.Group.Defs
import Mathlib.Algebra.Group.Subgroup.Lattice
import Mathlib.Data.Fin.Tuple.Basic
import Mathlib.Data.Finset.Defs
import Mathlib.Data.Finset.Lattice.Basic
import Mathlib.Data.Finset.Union
import Mathlib.GroupTheory.Finiteness
import Mathlib.Order.BoundedOrder.Basic

open Classical

variable {G : Type} [Group G]

def FiniteGeneratingSet (S : Finset G) : Prop :=
  Subgroup.closure ↑S = (⊤ : Subgroup G)

def SymmetricFiniteGeneratingSet (S : Finset G) : Prop :=
  (∀ s ∈ S, s⁻¹ ∈ S) ∧ FiniteGeneratingSet S

lemma symmetricFiniteGeneratingSetExists {G : Type} [hG : Group G] [h_FG : Group.FG G] :
  ∃ S : Finset G, SymmetricFiniteGeneratingSet S := by
    obtain ⟨ S, hS ⟩ := h_FG.out
    let S_inv : Finset G := S.image (·⁻¹)
    let S' : Finset G := S ∪ S_inv
    use S'
    constructor
    · aesop
    · have hSub : S ⊆ S' := by
        apply Finset.subset_union_left
      have hClosure := @Subgroup.closure_mono G hG S S' hSub
      rw [hS] at hClosure
      exact top_le_iff.mp hClosure

noncomputable
def minimalWordLength (S : Finset G) (g : G) : ℕ :=
  -- We don't have that S is a generating set here, so in general we could get a value of 0 for
  -- elements not in the subgroup generated by S. This is fine for the purposes of the gap
  -- conjecture but is maybe awkward in general?
  if g ∈ S then 1
  else
    let wordLengths : Set ℕ := {n : ℕ | ∃ (w : List G), (∀ s ∈ w, s ∈ S) ∧ w.prod = g ∧ w.length = n}
    sInf wordLengths

def prodOfWord {n : ℕ} {S : Finset G} (w : Fin n → S) : G :=
  (List.ofFn (fun i => ↑(w i))).prod

lemma prodOfWord_product_left {n : ℕ} {S : Finset G} (w : Fin n.succ → S) :
  prodOfWord w = (↑(w 0)) * prodOfWord (Fin.tail w) := by
    rw [prodOfWord, prodOfWord]
    simp only [Nat.succ_eq_add_one, List.ofFn_succ, List.prod_cons, Fin.tail]

lemma prodOfWord_product_right {n : ℕ} {S : Finset G} (w : Fin n.succ → S) :
  prodOfWord w = prodOfWord (Fin.init w) * (↑(w (Fin.last n))) := by
  rw [prodOfWord, prodOfWord]
  have h : List.ofFn (fun i ↦ (w i : G)) = (List.ofFn fun i ↦ ↑(Fin.init w i)).concat (↑(w (Fin.last n))) := by
    exact List.ofFn_succ' fun i ↦ (w i : G)
  rw [h]
  apply List.prod_concat

noncomputable
def wordNShell (S : Finset G) (n : ℕ) : Finset G :=
  let wordsOfLength_n : Finset (Fin n → S) := Finset.univ
  wordsOfLength_n.image (fun w ↦ prodOfWord w)

noncomputable
def wordNBall (S : Finset G) (n : ℕ) : Finset G :=
  (Finset.range (n + 1)).biUnion (wordNShell S ·)

lemma wordNPlus1Shell_from_wordNShell (S : Finset G) (n : ℕ) :
  ∀ w ∈ wordNShell S (n + 1), ∃ s ∈ S, ∃ w' ∈ wordNShell S n,
  w = s * w' := by
    intro w hw
    rw [wordNShell] at hw
    simp only [Finset.mem_image] at hw
    obtain ⟨ f, hf1, hProd ⟩ := hw
    rw [prodOfWord_product_left] at hProd
    use (f 0 : S)
    constructor
    · simp
    · rw [wordNShell]
      simp only [Finset.mem_image]
      use prodOfWord (Fin.tail f)
      have hh : Fin.tail f ∈ Finset.univ := by
        exact Finset.mem_univ (Fin.tail f)
      constructor
      · use (Fin.tail f)
      · subst hProd
        trivial

lemma wordNShell_mul_wordNPlus1Shell_left (S : Finset G) (n : ℕ) :
  ∀ w ∈ wordNShell S n, ∀ s ∈ S, s * w ∈ wordNShell S (n + 1) := by
    sorry

lemma wordNPlusKShell_from_wordNShell (S : Finset G) (n k : ℕ) :
  ∀ w ∈ wordNShell S (n + k), ∃ wₖ ∈ wordNShell S k, ∃ wₙ ∈ wordNShell S n,
  w = wₖ * wₙ := by
    induction k with
    | zero =>
      intro w hw
      use 1
      constructor
      · simp [wordNShell, prodOfWord]
      · use w
        constructor
        · exact hw
        · simp
    | succ k ih =>
      intro w hw
      obtain ⟨ s, hsS, w', hw', hw_eq ⟩ := wordNPlus1Shell_from_wordNShell S (n + k) w hw
      obtain ⟨ wₖ, hwₖ, wₙ, hwₙ, hw'_eq ⟩ := ih w' hw'
      use (s * wₖ)
      constructor
      · simp [wordNShell_mul_wordNPlus1Shell_left S k wₖ hwₖ s hsS]
      · use wₙ
        constructor
        · exact hwₙ
        · rw [hw_eq, hw'_eq]
          rw [mul_assoc]

lemma wordNPlus1Ball_union_WordNBall_WordNPlus1Shell (S : Finset G) (n : ℕ) :
  wordNBall S (n + 1) = wordNBall S n ∪ wordNShell S (n + 1) := by
    simp_all [wordNBall]
    rw [Finset.range_succ]
    rw [Finset.biUnion_insert]
    apply Finset.union_comm

lemma wordNBall_subset_wordNPlus1Ball (S : Finset G) (n : ℕ) :
  wordNBall S n ⊆ wordNBall S (n + 1) := by
    rw [wordNBall, wordNBall]
    have h : Finset.range (n + 1) ⊆ Finset.range (n + 1 + 1) := by
      simp only [Finset.range_subset, Nat.le_add_right]
    exact Finset.biUnion_subset_biUnion_of_subset_left (fun x ↦ wordNShell S x) h

lemma wordNShell_subset_H (S : Finset G) (H : Subgroup G) (hS : (S : Set G) ⊆ H.carrier) :
  ∀ n : ℕ, (wordNShell S n : Set G) ⊆ H.carrier := by
    intro n
    induction n with
    | zero =>
      simp [wordNShell, prodOfWord]
    | succ n ih =>
      intro g hg



lemma wordNBall_subset_H (S : Finset G) (H : Subgroup G) (hS : (S : Set G) ⊆ H.carrier) :
  ∀ n : ℕ, (wordNBall S n : Set G) ⊆ H.carrier := by
    intro n
    induction n with
    | zero =>
      simp [wordNBall, wordNShell, prodOfWord]
    | succ n ih =>
      intro g hg
      rw [wordNPlus1Ball_union_WordNBall_WordNPlus1Shell] at hg
      sorry


lemma wordNBallsCoverQQ {S : Finset G} {H : Subgroup G} (h : Subgroup.closure ↑S = H) :
  ∀ h : H, ∃ i, (h : G) ∈ wordNBall S i := by
    rw [Subgroup.closure] at h
    simp_all

lemma wordNBallsCoverG {S : Finset G} (hS : FiniteGeneratingSet S) :
  ⋃ n : ℕ, wordNBall S n = (⊤ : Subgroup G).carrier := by
    ext g
    constructor
    · simp
    · intro hg
      rw [FiniteGeneratingSet, Subgroup.closure] at hS
      simp_all





-- lemma finiteGeneratingSet_equiv (S S' : Finset G) (hS : FiniteGeneratingSet S) (hS' : FiniteGeneratingSet S') :
--   ∃ C : ℕ, S' ⊆ wordNBall S C := by
--     have qq : ∀ s' ∈ S', ∃ C_s' : ℕ, s' ∈ wordNBall S C_s' := by
--       intro s' hs'


lemma wordNBall_subset_qq (S S' : Finset G) (hS : FiniteGeneratingSet S) (hS' : FiniteGeneratingSet S') :
  ∃ C : ℕ, ∀ n : ℕ, wordNBall S n ⊆ wordNBall S' (C * n) := by
    sorry

lemma wordNShellLipschitz (S S' : Finset G) (hS : FiniteGeneratingSet S) (hS' : FiniteGeneratingSet S') :
  ∃ C : ℕ, ∀ n : ℕ, (wordNShell S n).card ≤ C * (wordNShell S' n).card := by
    sorry

lemma wordNBallLipschitz (S S' : Finset G) (hS : FiniteGeneratingSet S) (hS' : FiniteGeneratingSet S') :
  ∃ C : ℕ, ∀ n : ℕ, (wordNBall S n).card ≤ C * (wordNBall S' n).card := by
    obtain ⟨ C1, hC1 ⟩ := wordNShellLipschitz S S' hS hS'
    use C1
    intro n
    rw [wordNBall, wordNBall]
    sorry
    -- apply Finset.card_biUnion_le
